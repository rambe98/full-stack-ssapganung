CONCATENATION(연결)
println("안녕" + "하세요") -> 자바 방식

||( 연결 기호) -> sql 방식

Alias(as)
별칭(컬럼의 길이나 식이 너무 길다면 대신 사용할 수 있다.)
- as 뒤에 별칭 작성하기
- 컬럼명 뒤에 작성하기
- from절에 테이블 명 뒤에 한칸 띄우고 작성

별칭의 특징
테이블에 별칭을 줘서 컬럼을 단순, 명확히 할 수 있다.
현재의 SELECT 문장에서만 유효하다.
테이블 별칭은 길이가 30자까지 가능하나 짧을수록 좋다.
테이블 별칭에는 의미가 잇어야 한다.
FROM절에 테이블 멸칭 설정시 해당 테이블 별칭은 SELECT문장에서 테이블 이름 대신에 사용한다.

JOIN
데이터베이스에서 '두 개 이상의 테이블'을 연결하여 '하나의 결과의 테이블'로 만드는 것을 의미한다.
이를 통해 데이터를 효율적으로 검색하고 처리하는데 도움을 준다.
JOIN을 사용하는 이유는 데이터베이스에서 테이블을 분리하여 '데이터 중복을 최소화'하고 '데이터의 일관성'을 유지하기 위함이다.
여러가지 JOIN의 방식이 있으며 JOIN방식에 따라 결과가 달라진다.

JOIN의 종류
1. Inner Join
각 테이블에서 조인 조건에 일치되는 데이터만 가져온다.
A와 B테이블의 공통된 부분을 의미한다 보통 교집합 이라고 부른다.
보통 교집합이라고 부른다

select* from 테이블명A INNER JOIN 테이블명B ON 조건식
select* from 테이블명A JOIN 테이블명B ON 조건식

pk와 kf

pk와 fk로 연결되어 있는 테이블끼리 join을 한다.

SELF INNER JOIN
하나의 테이블 내에서 다른 컬럼을 참조하기 위해 사용하는 '자기 자신과의 조인'방법이다.
이를 통해 데이터베이스에서 한 테이블 내의 값을 다른 값과 연결할 수 있다.

CROSS INNER JOIN
두 개 이상의 테이블에서 '모든 가능한 조합'을 만들어 결과를 반환하는 조인 방법이다.
이를 통해 두 개 이상의 테이블을 조합하여 새로운 테이블을 생성할 수 있습니다
Cross Join은 일반적으로 테이블 간의 관계가 없을 때 사용된다.
각 행의 모든 가능한 조합을 만들기 때문에 결과가 매우 큰 테이블이 될 수 있으므로 사용에 주의가 필요하다.

OUTER JOIN 
-  두 테이블에서 '공통된 값을 가지지 않는 행들'도 반환한다.
- Left Outer join, Right Outer join, Full Outer Join의 종류가 있다.

LEFT OUTER JOIN
- '왼쪽 테이블의 모든 행'과 '오른쪽 테이블에서 왼쪽 테이블과 공통된 값'을 가지고 있는 행들을 반환한다.
- 교집합의 연산결과와 차집합의 연산 결과를 합친것과 같다.
- 만약 오른쪽 테이블에서 공통괸 값을 가지고 있는 행이 없다면 NULL값을 반환한다

SELECT * FROM 테이블A LEFT OUTTER JOIN 테이블B
ON 테이블A.컬럼 = 테이블A.컬럼

RIGHT OUTER JOIN
LEFT OUTER JOIN의 반대이다.
RIGHT OUTER JOIN 키워드의 오른쪽에 명시된 테이블에만 존재하는 데이터를 추출한다.

SELECT * FROM 테이블A RIGHT OUTTER JOIN 테이블B
ON 테이블A.컬럼 = 테이블A.컬럼

상황에 따라 어떤걸 사용해야하는지는 다르지만
대부분의 경우 왼쪽 테이블의 데이터를 기준으로 분석할 때가
많기때문에 LEFT OUTTER JOIN을 좀 더 많이 사용한다.

FULL OUTER JOIN
두 테이블에서 '모든 값'을 반환한다. 
만약 공통된 값을 가지고 있지 않는 행이 있다면 NULL값을 반환한다.
합집합 연산 결과와 같다.
양쪽 테이블 데이터 집합에서 공통적으로 존재하는데이터, 
한쪽에만 존재하는 데이터 모두 추출한다.

SELECT * FROM 테이블A FULL OUTTER JOIN 테이블B
ON 테이블A.컬럼 = 테이블A.컬럼

VIEW
하나 이상의 테이블이나 다른 뷰의 데이터를 볼 수 있게 하는 데이터베이스 객체이다.
실제 데이터는 뷰를 구성하는 테이블에 담겨 있지만 마치 테이블 처럼 사용할 수 있다.
테이블 뿐만 아니라 다른 뷰를 참조해 새로운 뷰를 만들어서 사용할 수 있다.

VIEW의 사용 목적
코딩을 하다보면 여러개의 테이블에서 필요한 정보를 뽑아 사용할때가 많다.
이때 좀 더 편리하게 사용할 수 있는 방법중의 하나가 VIEW이다.
VIEW를 사용하면 복잡한 쿼리문을 간단하게 만들어준다.
여러 테이브르이 JOIN과 GROUP BY같은 복잡한 쿼리를 VIEW로 저장시켜 놓으면 다음부터는 저장한 VIEW만 호출하면 된다.

view의 특징
독립성
테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.
편리성
복잡한 쿼리문을 뷰로 생성함으로써 관련 쿼리를 단순하게 작성할 수 있다.
또한 해당 형태의 SQL문을 자주 사용할 때 뷰를 이용하면 편리하게 사용할 수 있다.
보안성
직원의 급여정보와 같이 숨기고 싶은 정보가 존재한다면, 
뷰를 생성할 때 해당 칼럼을 빼고 생성함으로써 사용자에게 정보를 감출 수 있다.

-- VIEW의 생성
CREATE VIEW 뷰이름 AS
(
  쿼리문
)
-- VIEW의 수정
-- OR REPLACE 옵션은 기존의 정의를 변경하는 데 사용할 수 있다.
CREATE OR REPLACE VIEW 뷰이름 AS
(
  쿼리문
)
-- VIEW의 삭제
DROP VIEW 뷰이름 [RESTRICT OR CASCADE]
※RESTRICT : 뷰를 다른곳에서 참조하고 있다면 삭제가 취소된다.
※CASCADE : 뷰를 참조하는 다른 뷰나 제약 조건까지 모두 삭제된다.

TCL(Transaction Control Language): (DML을 위한 명령어) 트랜젝션 제어 언어
트랜잭션 : 데이터베이스의 작업을 처리하는 논리적 연산 단위[분리될 수 없는 최소 단위]
 ㄴ 쿼리문 하나가 트랜잭션이다~ 쉽게 생각하면
어떠한 작업을 하기 위해서는 Select ,Insert, Update 를 사용해야 하는데 이걸 하나의 작업 단위라고 한다.

트랜잭션의 특성
원자성(Atomicity) : 원자와 같이 데이터베이스 연산들이 나눌수도, 줄일수 없는 하나의 유닛으로서 취급됨.
트랜잭션에 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아야 함
일관성(Consistency) : 데이터베이스의 트랜잭션이 제약조건, cascades, triggers를 포함한 정의된 모든 조건에 맞게 데이터 값이 변경됨
트랜잭션 실행 전의 데이터베이스 내용이 잘못되지 않으면 트랜잭션 실행 후에도 데이터베이스 내용이 잘못되면 안됨
고립성(Isolation) : 특정 DBMS에서 다수의 유저들이 같은 시간에 같은 데이터에 접근하였을 때 수행중인 트랜잭션이 완료될 때 까지
다른 트랜잭션의 요청을 막음으로서 데이터가 꼬이는걸 방지한다.
트랜잭션 실행 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들면 안됨
영속성,지속성(Durability) : 트랜잭션 실행이 성공적일 때, 그 트랜잭션이 갱신한 데이터베이스 내용은 영구적으로 저장됨.

TCL의 종류
1. COMMIT : DML로 변경된 데이터를 데이터베이스에 적용할 때 사용
COMMIT문 사용시 이전 데이터는 영원히 지워짐
COMMIT문 사용시 모든 사용자가 변경된 데이터 확인 가능
SQLServer는 기본적으로 AUTO COMMIT모드이므로 자동으로 COMMIT을 수행한다.
(DML문이 성공하면 자동으로 COMMIT을 실행한다.)
COMMIT 실행시 하나의 트랜잭션 과정을 종료
→ COMMIT이 실행되기 전에 다른 사용자가 완료되지 않은 데이터를 보거나 변경할 수 없음
사용법 : COMMIT;

2. ROLLBACK : DML로 변경된 데이터를 변경 이전 상태로 되돌릴 때 사용
데이터에 대한 변경사항 취소
ROLLBACK문 사용시 이전 데이터 다시 재저장 -> COMMIT되지 않은 상위 트랜잭션을 모두 ROLLBACK시킴
ROLLBACK문 사용시 관련 행의 잠금(LOCKING)이 풀려 다른 사용자들이 데이터 변경 가능
SQL Server는 기본적으로 AUTO COMMIT모드이므로 자동으로 COMMIT, 오류가 발생하면 자동으로 ROLLBACK처리
사용법 : ROLLBACK;

3. SAVEPOINT : 오류 복구 처리에 효과적인 방법 -> 전체 트랜잭션을 ROLLBACK하지 않고도 오류 복귀 가능
효과적으로 오류 복구 처리를 위해 저장점을 저장할 때 사용
-> 전체 트랜잭션을 ROLLBACK하지 않고 현시점에서 SAVEPOINT까지 일부 트랜잭션만 오류 복귀 가능
복잡한 대규모 트랜잭션에서 에러가 발생했을 때 주로 사용
복수의 저장점 정의 가능
저장점까지 롤백할 때는 "ROLLBACK TO 저장점;" 사용
세이브 포인트 만드는 법: SAVEPOINT 세이브포인트이름;
사용법: ROLLBACK TO 세이브포인트이름;




/*	인터페이스
	모든 메서드가 추상 메서드인 일종의 추상 클래스를 '인터페이스'라고 부른다.
	인터페이스는 추상 메서드와 상수 로만 이루어져 있으며, 
	추상클래스와 마찬가지로 스스로 객체를 생성할 수 없다.
	언뜻 보면 인터페이스와 추상 클래스가 같은 역할을 하는 것처럼 느껴질 수 있지만, 취지는 완전히 다르다.
	
	추상 클래스는 자식클래스들의 공통적인 특징을 추출하고 
	제공하는것이 주된 역할이었다면 인터페이스는 그뿐 아니라 
	다른 클래스 코드들과의 중간 매개 역할을 하는 것을 중점으로 생각할 수 있다.
	
	인터페이스의 선언
	인터페이스는 클래스가 아니다.
	추상클래스는 스스로 객체를 생성할 수는 없지만, 자식 클래스의 생성자를 통해 객체를 생성해낼 수 있었다.
	하지만 인터페이스는 어떤 형태로도 객체를 만들 수 없기 때문에 클래스라고 부를 수 없다.
	인터페이스는 객체의 매개체, 즉, 객체를 사용하는 방법을 제공하는 새로운 블록이라고 할 수 있다.
	예)
	[접근제한자]interface 인터페이스명{
	//상수
	//추상메서드
	//}
	인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 동일하며 
	class키워드 대신 interface를 작성한다.
	또한, 인터페이스의 추상 메서드는 다른 클래스들과의 매개체 역할을 하므로 누구나 접근할 수 있다.
	따라서 항상 public으로 구현한다.
	만약 접근자를 default로 구현했다면 자동으로 public으로 인식한다.
	
	추상 클래스는 추상 메서드가 비어있기 때문에 객체 생성을 스스로 할 수 없다.
	대신 자식 클래스의 생성자의 힘을 빌려 객체 생성을 할 수 있었다.
	인터페이스도 마찬가지로 추상 메서드가 비어있기 때문에 객체 생성을 스스로 할 수 없다.
	따라서 인터페이스도 자신이 가지고 있는 추상 메서드를 구현해줄 클래스를 작성해야만 한다.
	인터페이스를 구현해주는 클래스를 '구현 클래스'라고 한다.
	
	인터페이스의 장점
	정보은닉 : 실제 구현 클래스의 내용을 전혀 보지 않고도 개발 코드로 객체를 사용할 수 있다.
	모듈화 : 구현 클래스들이 독립적으로 구현되고 사용될 수 있다. 
	       개발 코드에서 객체 변경이 필요할 때, 개발코드의 수정을 최소화할 수 있다.
	       
	추상 클래스와 인터페이스의 공통점
	정보은닉, 모듈화, 추상화 등은 추상클래스와 인터페이스가 공통적으로 가진 장점이다.
	추상 클래스와 인터페이스 모두 다형성을 구현할 수 있는 기반을 제공하며, 
	추상 메서드 구현에 대한 강제성을 반영하고 있다.
	
 */

package interface_ex;

public class PersonMain {
	public static void main(String[] args) {
		Person han = new Person(new PineApplePhone());
		han.turnOnPhone();
		for(int i = 1; i < 6; i++) {
			han.watchUtube();
			
			if(i % 3 == 0) {
				han.chargePhone();
			}
		}
		han.buyNewPhone(new ThreeStarPhone());
		han.turnOnPhone();
		
		for(int i = 1; i < 5; i++) {
			han.watchUtube();
			
			if(i % 3 == 0) {
				han.chargePhone();
			}
		}
	}
	//  자식 / extends / super / == / implements
}

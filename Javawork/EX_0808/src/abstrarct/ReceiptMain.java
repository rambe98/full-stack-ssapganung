/*	추상화
	공통성과 본질을 모아 추출하는것
	기존 클래스들의 공통적인 요소를 모아 상위 클래스를 만들어내는 기술
	공통적인 속성과 행위를 모아 정의하면, 반복적인 코드를 줄일수 있고, 
	보다 효과적인 클래스간의 관계를 설정하여 유지보수가 용이해진다.
	- 바로 전에 작성했던 FarmTest에서 메서드 오버라이딩을 이용하여 처리한 경우를 다시한번 살펴보자.
	- Animal클래스의 cry()메서드가 텅 비어있는 것을 확인할 수 있다.
	- Animal 객체를 통해 직접 cry()메서드를 호출할 일은 없지만,
	- Animal클래스를 상속받은 자식 클래스들이 cry()메서드를 오버라이딩 하여 재정의 하고
	- 타입변환을 통해서 그 메서드를 사용하기 위함이었다.
	
	추상메서드
	선번부만 작성하고 구현부는 작성하지 않고 남겨둔 미완성 메서드를 '추상 메서드'라고 한다.
	다형성을 위해 메서드의 선언은 통일해야 하지만, 실제로 구현하는 내용은 자식클래스마다 달라야 할 때
	부모 클래스의 메서드는 비워두고 자식 클래스에서 오버라이딩하여 구현을 할 수 있다.
	추상 메서드를 선언할 때 abstract 키워드를 함께 표기해야 한다.
	또한 메서드의 구현부인 중괄호{} 대신 구현부가 없다는 의미로 세미콜론(;)를 쓴다.
	
	예시)
	[접근제한] abstract [반환형] [메서드명](파라미터1,파라미터2);
	abstract [접근제한] [반환형] [메서드명](파라미터1,파라미터2);
	
	추상 클래스(abstract class)
	추상메서드가 한 개 이상 정의되어 있는 클래스를 추상 클래스라고 한다.
	추상 메서드를 포함하고 있다는 것을 제외하고 일반 클래스와 다르지 않다.
	추상 클래스에도 생성자가 있으며, 멤버변수와 메서드도 가질 수 있다.
	추상 클래스 또한 abstract를 통해 자신이 추상클래스임을 명시해줘야 한다.
	예시)
	[접근제한] abstract class [클래스명]{
	//필드
	//생성자
	//메서드(추상메서드 포함)
	//}
	 * 
	추상 클래스의 특징
	일반 클래스 처럼 독립적으로 생성자를 호출해 객체를 생성할 수 없다.
	자식 클래스의 생성자에 super()를 총해 추상 클래스의 생성자를 호출하여 
	부모 객체를 생성한 후 자식 객체를 생성한다.
	
	추상클래스에 추상메서드는 언제 구현해야 할까??
	
	자식 클래스들이 반드시 구현해야 하는 메서드가 있다면, 
	우리는 추상 메서드로 해당 메서드를 부모 클래스(추상클래스)에 선언해 둘 수 있다.
	
	자식 클래스에 반드시 구현해야하는 메서드가 있다면, 추상메서드로 추상클래스에 만들어준다.
	추상 클래스를 상속받은 모든 자식 클래스는 
	반드시 추상 메서드를 오버라이딩 및 재정의하여 구현해야 한다.
	그렇지 않으면 컴파일 에러가 발생한다.
	
 */

package abstrarct;

public class ReceiptMain {

	public static void main(String[] args) {
		//Receipt r = new Receipt(); //-> 추상클래스는 직접 객체를 생성할 수 없음
		
		PastaReceipt pr = new PastaReceipt("최연석");
		pr.info(); //자식객체를 통해 추상 클래스의 메서드를 호출할 수 있음
		pr.makeSource();
			
		StakeReceipt sr = new StakeReceipt("이현복");
		sr.info();
		sr.grillStake();

		/* 	추가 설명
		 	추상클래스는 사실 일반 클래스와 크게 다를것은 없어보이지만, 
		 	직접 객체를 생성하지 못한다는 사실을 알 수 있다.
		 */
		
		
	}

}
